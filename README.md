# Spring Project

Проект демонстрирует различные аспекты работы Spring Framework через отдельные ветки репозитория.
В проекте используется Java 21, SpringBoot 3.x, Maven и другие технологии.

## Структура веток

### Ветка `exercise1` - Spring Core: Bean Lifecycle & Caching Using Custom Proxy

- Проект демонстрирует работу жизненного цикла бинов в Spring. Механизмы кэширования через прокси с помощью кастомного
  создания ProxyFactory и MethodInterceptor. А также механизмы кастомной обработки бинов.

**Реализованные возможности:**

- Полный жизненный цикл бинов Spring (от создания до уничтожения)
- Кастомная аннотация `@CacheResult` для кэширования результатов методов
- Реализация `BeanPostProcessor` и `BeanFactoryPostProcessor`
- Работа с `@PostConstruct` и `@PreDestroy`
- Сравнение singleton и prototype бинов
- Динамическое проксирование методов. Кастомный интерцептор `CacheResultMethodInterceptor`
- Двухуровневое потокобезопасное кэширование
- После запуска программы в логах будет отображен полный цикл работы бинов

**Технологический стек:**
Java 21, Spring Boot 3.x, Maven, Lombok. Module Spring(Core)

### Ветка `exercise2` - Spring AOP: Caching, Validation, Logging and Exception Handling

- Проект демонстрирует работу с аспектно-ориентированным программированием (AOP) для реализации кросс-функциональных задач.

**Реализованные возможности:**

- Кэширование результатов методов с кастомной аннотацией @CacheResult при помощи AOP
- Проверка запросов перед выполнением методов с кастомной аннотацией @CheckRequest при помощи AOP
- Централизованное логирование начала и окончания выполнения методов при помощи AOP
- Централизованная обработка исключений при помощи AOP
- Создание кастомного исключения
- Подробное логирование всех этапов выполнения

**Технологический стек:**
Java 21, Spring Boot 3.x, Maven, Lombok. Module Spring(Core, AOP)

### Ветка `exercise3` - Spring REST: Optimized CRUD with In-Memory Storage

- Проект демонстрирует работу сервиса для управления банковскими счетами пользователей. Сервис предоставляет REST API
  для выполнения CRUD операций с банковскими счетами с применением in-memory хранилища.

**Реализованные возможности:**

- Получение информации о счетах (по ID счета или по ID пользователя)
- Создание новых счетов (проверка на дубликаты счетов)
- Обновление существующих счетов (запрет на изменение номера счета после создания)
- Удаление счетов (отдельного счета или всех счетов пользователя)
- Обработка различных исключительных ситуаций и валидацию входных данных.
- Специализированные исключения для различных сценариев
- Стандартизированный формат ответа об ошибках (ErrorDto)

**Технологический стек:**
Java 21, Spring Boot 3.x, Maven, Lombok. Module Spring(Core, Web, Validation)

### Ветка `exercise4` - Spring (Core, AOP, MVC, Data) с применением PostgreSQL

**Реализованные возможности:**

- Проект представляет собой:
    - RESTful API для банковской системы, реализующей основные операции по управлению пользователями, банковскими
      счетами и транзакциями.
- Приложение следует стандартной трехуровневой архитектуре:
    - Контроллеры - обработка HTTP запросов, валидация входящих данных
    - Сервисы - бизнес-логика, взаимодействие с репозиториями, обработка ошибок
    - Хранилище данных PostgreSQL - с использованием Spring Data JPA и Liquibase для управления миграциями
- Валидация:
    - Валидация и кастомные проверки бизнес-логики (проверка на дубликаты счетов, защита от изменения номера счета,
      проверка валют и достаточности средств и т.д.)
    - Кастомная валидация через `@Currency`, которая проверяет существование валюты в БД
- Обработка ошибок:
    - Глобальный обработчик исключений через `@RestControllerAdvice` и `@ExceptionHandler`
    - Стандартизированный формат ошибок (ErrorDto)
    - Подробные сообщения об ошибках с кодами
- Также было использовано:
    - Маппинг между DTO и Entity через MapStruct
    - Обработка входящих запросов через `@RestController`
    - Развертывание PostgreSQL в Docker
    - Все таблицы связаны через внешние ключи
    - Логирование всех операций

**Перед запуском программы необходимо запустить локально Docker и в терминале выполнить команду docker-compose up**